This is Readme
# part 1 

# part 2 Json 数字语法

number = [ "-" ] int [ frac ] [ exp ];

int = "0" / digit1-9 *digit

frac = "." 1*digit

exp = ("e" / "E") ["-" / "+"] 1*digit


number 是以十进制表示，它主要由 4 部分顺序组成：负号、整数、小数、指数。只有整数是必需部分。注意和直觉可能不同的是，正号是不合法

使用 #if 0 ... #endif 而不使用 /* ... */，是因为 C 的注释不支持嵌套（nested），而 #if ... #endif 是支持嵌套的。代码中已有注释时，用 #if 0 ... #endif 去禁用代码是一个常用技巧，而且可以把 0 改为 1 去恢复。

# part 3 解析字符串
## 1、json字符串语法
C 语言和 JSON 都使用 \（反斜线）作为转义字符，那么 " 在字符串中就表示为 \"，a"b 的 JSON 字符串则写成 "a\"b"。如以下的字符串语法所示，JSON 共支持 9 种转义序列：

```cpp
string = quotation-mark *char quotation-mark
char = unescaped /
   escape (
       %x22 /          ; "    quotation mark  U+0022
       %x5C /          ; \    reverse solidus U+005C
       %x2F /          ; /    solidus         U+002F
       %x62 /          ; b    backspace       U+0008
       %x66 /          ; f    form feed       U+000C
       %x6E /          ; n    line feed       U+000A
       %x72 /          ; r    carriage return U+000D
       %x74 /          ; t    tab             U+0009
       %x75 4HEXDIG )  ; uXXXX                U+XXXX
escape = %x5C          ; \
quotation-mark = %x22  ; "
unescaped = %x20-21 / %x23-5B / %x5D-10FFFF
```
## 2、字符串表示
**实现原理**：当遇到“时开始解析字符串，首先备份栈顶的位置，用一个指针指向字符串的首地址，然后指针往后走，其中用一个临时缓冲区数据结构为栈存储字符。

（1）如果遇到”,用该位置减去备份的栈顶位置即为字符串的长度；一次性弹出所有的字符。返回成功；注意在设置这个 `v` 之前，我们需要先调用 `lept_free(v)` 去清空 `v` 可能分配到的内存。例如原来已有一字符串，我们要先把它释放。然后就是简单地用 `malloc()` 分配及用 `memcpy()` 复制，并补上结尾空字符。`malloc(len + 1)` 中的 1 是因为结尾空字符。返回成功；

（2）如果遇到‘\0'，表明字符串结束，缺少右引号，返回缺少引号的错误；

（3）如果是字符，则入栈；其中如果栈的大小不足，会以1.5倍扩容。和普通的堆栈不一样，我们这个堆栈是以字节储存的。push每次可要求压入任意大小的数据，它会返回数据起始的指针，栈顶指针每次后移动size大小。

---------------------------------------
在 C 语言中，字符串一般表示为空结尾字符串（null-terminated string），即以空字符（'\0'）代表字符串的结束。然而，JSON 字符串是允许含有空字符的，例如这个 JSON "Hello\u0000World" 就是单个字符串，解析后为11个字符。如果纯粹使用空结尾字符串来表示 JSON 解析后的结果，就没法处理空字符。

因此，我们可以分配内存来储存解析后的字符，以及记录字符的数目（即字符串长度）。由于大部分 C 程序都假设字符串是空结尾字符串，我们还是在最后加上一个空字符，那么不需处理 \u0000 这种字符的应用可以简单地把它当作是空结尾字符串

## 3、内存管理
由于字符串的长度不是固定的，需要动态的分配内存。用malloc()、realloc()和free()来分配/释放内存；

注意，在设置这个lept_value* v 之前，我们需要先调用 lept_free(v) 去清空 v 可能分配到的内存。例如原来已有一字符串，我们要先把它释放。然后就是简单地用 malloc() 分配及用 memcpy() 复制，并补上结尾空字符。malloc(len + 1) 中的 1 是因为结尾空字符

## 4、缓冲区和堆栈
解析字符串（以及之后的数组、对象）时，需要把解析的结果先储存在一个临时的缓冲区，最后再用 lept_set_string() 把缓冲区的结果设进值之中。在完成解析一个字符串之前，这个缓冲区的大小是不能预知的。因此，我们可以采用动态数组（dynamic array）这种数据结构，即数组空间不足时，能自动扩展。C++ 标准库的 std::vector 也是一种动态数组。

而且我们将会发现，无论是解析字符串、数组或对象，我们也只需要以先进后出的方式访问这个动态数组。换句话说，我们需要一个动态的堆栈（stack）数据结构。

## 内存泄漏检测方法
Liunx 系统下 
命令行 ` valgrind --leak-check= full ./lept_json.test`

Valgrind 还有很多功能，例如可以发现未初始化变量。我们若在应用程序或测试程序中，忘了调用 lept_init(&v)，那么 v.type 的值没被初始化，其值是不确定的（indeterministic），一些函数如果读取那个值就会出现问题：

## Q&A
2.实现除了 \u 以外的转义序列解析，令 test_parse_string() 中所有测试通过。

**解析**：当遇到字符'\'时，增加swith case语句；

**遇到的问题**：测试test_parse_string()，遇到段错误（segmentation fault)

**解决问题思路**：实现肯定是解析字符串时候发生的，而且段错误一般是非法访问内存，常见于`malloc()`之类的动态内存分配，申请内存之后没有将指针赋值为`NULL`。或者数组访问越界，或者栈中定义过大的数组，导致栈空间不足；

排查之后发现，在字符串push操作的返回的指针越界导致的.之前为`ret = c->stack + c->size` `c->top += c->size()`,而`c->size`初始值为256,后面使用时发生错误，此处为逻辑错误，没有思考清楚，应该改为：

```cpp
ret = c->stack + c->top; /* 这里【注意】加上c->top,每次指向要下一个要push位置的指针 */
c->top += size; /* top栈顶指针移动size大小 */
```

3、不合法的字符串
```cpp
unescaped = %x20-21 / %x23-5B / %x5D-10FFFF
```
当中空缺的 %x22 是双引号，%x5C 是反斜线，都已经处理。所以不合法的字符是 %x00 至 %x1F。我们简单地在 default 里处理：

4、性能优化的思考
摘自原github：

https://github.com/miloyip/json-tutorial/blob/master/tutorial03_answer/tutorial03_answer.md

1、如果整个字符串都没有转义符，我们不就是把字符复制了两次？第一次是从 json 到 stack，第二次是从 stack 到 v->u.s.s。我们可以在 json 扫描 '\0'、'\"' 和 '\\' 3 个字符（ ch < 0x20 还是要检查），直至它们其中一个出现，才开始用现在的解析方法。这样做的话，前半没转义的部分可以只复制一次。缺点是，代码变得复杂一些，我们也不能使用 lept_set_string()。

2、对于扫描没转义部分，我们可考虑用 SIMD 加速，如 RapidJSON 代码剖析（二）：使用 SSE4.2 优化字符串扫描 的做法。这类底层优化的缺点是不跨平台，需要设置编译选项等。

3、在 gcc/clang 上使用 __builtin_expect() 指令来处理低概率事件，例如需要对每个字符做 LEPT_PARSE_INVALID_STRING_CHAR 检测，我们可以假设出现不合法字符是低概率事件，然后用这个指令告之编译器，那么编译器可能可生成较快的代码。然而，这类做法明显是不跨编译器，甚至是某个版本后的 gcc 才支持。